# 至少有K个重复字符的最长子串

给你一个字符串 `s` 和一个整数 `k` ，请你找出 `s` 中的最长子串， 要求该子串中的每一字符出现次数都不少于 `k` 。返回这一子串的长度。

如果不存在这样的子字符串，则返回 0。


## 问题分析

**关键点：**

1. 子串是  **连续的字符序列** ，不能跳过字符。
2. 子串中每个字符的出现次数都必须大于等于 `k`。
3. 我们需要返回符合条件的  **最长子串的长度** 。


## 滑动窗口解法

### 滑动窗口的核心思路：

1. **滑动窗口框架：** 我们通过使用两个指针 `left` 和 `right`，构成一个窗口，并在这个窗口内维护当前子串的字符统计情况。
2. **分治和限制字符种类数量：** 为了更好地处理字符出现次数的限制问题，我们可以通过限制窗口中不同字符的种类数来逐步逼近解。具体的做法是：
   * 通过设定窗口中字符种类数 `uniqueTarget`，我们先限制窗口中只包含 `1` 种字符，再逐渐增加种类数，依次检查包含 `1`、`2`、...、`N` 种字符的最长子串（`N` 为字符串中不同字符的最大数目）。
   * 对于每个种类数 `uniqueTarget`，我们在滑动窗口内维护两个信息：
     * `countMap`：用于记录窗口内每个字符的频次。
     * `atLeastKCount`：记录窗口内有多少个字符的出现次数大于等于 `k`。
3. **动态调整窗口：** 我们使用 `right` 指针逐步向右扩展窗口，当窗口中的字符种类超过 `uniqueTarget` 时，开始通过移动 `left` 指针来收缩窗口，直到窗口内字符种类数重新符合条件。
4. **满足条件时更新结果：** 当窗口内的字符种类数等于 `uniqueTarget`，并且所有字符的出现次数都不小于 `k` 时，我们更新最大子串长度。

### 滑动窗口解法步骤：

1. **初始化** ：我们先统计字符串 `s` 中的不同字符种类数 `maxUnique`，然后对于每个 `uniqueTarget` 从 `1` 到 `maxUnique` 逐步尝试用滑动窗口法找到符合要求的子串。
2. **维护滑动窗口** ：

   * 使用 `left` 和 `right` 作为滑动窗口的左右边界。
   * 使用 `countMap` 来记录窗口内每个字符的频次，并更新窗口中符合条件的字符数 `atLeastKCount`。
3. **扩展和收缩窗口** ：

   * 每次 `right` 向右扩展时，更新窗口中字符的频次信息。
   * 当窗口中的字符种类数超过 `uniqueTarget` 时，通过移动 `left` 来收缩窗口。
4. **检查条件并更新结果** ：当窗口内字符种类数等于 `uniqueTarget`，且所有字符的出现次数都大于等于 `k` 时，更新最大子串长度。
