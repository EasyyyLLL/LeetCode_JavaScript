# 长度最小的子数组

给定一个含有 `n` 个正整数的数组和一个正整数 `target` 。

找出该数组中满足其总和大于等于 `target` 的长度最小的 **子数组** $[nums_l, nums_{l+1}, ..., nums_{r-1}, nums_r]$ ，并返回其长度 **。** 如果不存在符合条件的子数组，返回 `0` 。


## 问题分析

**关键点：**

1. **子数组** 是数组中连续的一部分元素，这意味着只能从左到右地扩展或收缩区间。
2. 我们需要找到 **和大于等于 `target`** 的最短子数组。
3. 如果存在多个符合条件的子数组，要求返回长度最小的子数组。


## 滑动窗口解法

### 滑动窗口的核心思路：

1. **维护一个滑动窗口** ：使用两个指针 `left` 和 `right` 表示窗口的左右边界。`right` 用来扩展窗口，`left` 用来缩小窗口。窗口范围内的元素和表示当前子数组的和。
2. **动态调整窗口** ：

   * 我们从数组的第一个元素开始，通过移动 `right` 指针向右扩展窗口，不断累加窗口内的元素和 `sum`。
   * 当窗口内的元素和 `sum` 大于等于 `target` 时，记录当前窗口的长度（`right - left + 1`），并尝试通过移动 `left` 指针来缩小窗口，寻找更短的符合条件的子数组。
   * 一旦 `sum` 小于 `target`，停止收缩窗口，继续通过移动 `right` 来扩展窗口。
3. **更新结果** ：

   * 每当 `sum` 大于等于 `target` 时，检查当前窗口的长度是否是最短的，并更新最短长度。
4. **终止条件** ：

   * 遍历数组后，检查是否找到符合条件的子数组。如果找到了，返回最短长度；如果没有，返回 `0`。

### 滑动窗口解法的步骤：

1. 定义两个指针 `left` 和 `right`，初始都指向数组的起始位置。用 `sum` 来记录当前窗口内的元素和。
2. 让 `right` 指针从左到右逐个遍历数组，每次将当前 `nums[right]` 加入到 `sum` 中。
3. 当 `sum` 大于等于 `target` 时，记录当前窗口的长度，并尝试通过移动 `left` 来收缩窗口，寻找更短的子数组。
4. 如果 `sum` 小于 `target`，继续通过 `right` 指针扩展窗口。
5. 遍历完成后，返回找到的最短长度。如果没有找到符合条件的子数组，返回 `0`。
