# 两数之和

## 问题分析

定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值 ***`target`*  的那 **两个** 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。

你可以按任意顺序返回答案。

## 求解方法

该问题可以通过哈希表（`Map`）的方式高效解决。具体思路如下：

1. **目标**：找到两个数的和等于目标值 `target`。
2. **思路**：遍历数组，记录每个元素的值及其对应的下标，计算每个元素的互补值（`target - 当前元素`）。如果在遍历过程中，发现某个元素的互补值已经出现在哈希表中，则可以立即返回这两个元素的下标。
3. **哈希表的作用**：哈希表帮助我们快速查找互补值是否已经出现过，其查找时间复杂度为 O(1)，从而使得整个算法的时间复杂度较低。

### 时间复杂度分析

1. **遍历数组**：我们需要遍历整个数组一次，每次访问数组中的元素。
   - 时间复杂度为 O(n)，其中 n 是数组 `nums` 的长度。
2. **哈希表查找与插入操作**：对于每个元素，我们需要在哈希表中查找互补值是否存在，查找和插入哈希表的操作的时间复杂度为 O(1)。
   - 总的查找和插入操作的时间复杂度为 O(n)。

因此，该算法的总体时间复杂度为 **O(n)**，这是一个线性时间复杂度的算法，适合处理较大规模的数据。

### 空间复杂度分析

该算法使用了额外的哈希表来存储数组中已经遍历过的元素及其下标。哈希表的大小与数组长度 n 成正比，因此空间复杂度为 O(n)。

### 总结

1. **时间复杂度**：O(n)
   - 因为我们只需遍历数组一次，每次操作在哈希表中的查找与插入都是常数时间复杂度。
2. **空间复杂度**：O(n)
   - 额外的空间用于存储哈希表，其大小取决于数组的长度。
