# 二分查找

给定一个 `n` 个元素有序的（升序）整型数组 `nums` 和一个目标值 `target`  ，写一个函数搜索 `nums` 中的 `target`，如果目标值存在返回下标，否则返回 `-1`。


## 问题分析

给定一个已经  **有序的整型数组** ，并且是升序排列，要求我们找到目标值 `target` 在数组中的位置。如果目标值存在于数组中，则返回该目标值的下标；如果目标值不存在，则返回 `-1`。由于数组是有序的，最合适的搜索方法是  **二分查找算法** ，它的时间复杂度是 O(log n)，非常适合在有序数组中查找目标值。

## 二分算法解法

二分查找的做法是，定义查找的范围 [left,right]，初始查找范围是整个数组。每次取查找范围的中点 mid，比较 nums[mid] 和 target 的大小，如果相等则 mid 即为要寻找的下标，如果不相等则根据 nums[mid] 和 target 的大小关系将查找范围缩小一半。

1. **定义左右边界** ：
   * 定义两个指针：`left` 指针指向数组的最左边（即第一个元素的下标），`right` 指针指向数组的最右边（即最后一个元素的下标）。
2. **计算中间位置** ：
   * 计算当前搜索范围的中间位置 `mid`，用公式 `mid = Math.floor((left + right) / 2)` 得到。中间位置是搜索的切分点，用它来判断目标值是否位于中间位置，或者在哪一侧。
3. **判断目标值位置** ：
   * 如果 `nums[mid] == target`，则找到了目标值，返回 `mid` 位置。
   * 如果 `nums[mid] > target`，说明目标值位于左侧，更新 `right = mid - 1`。
   * 如果 `nums[mid] < target`，说明目标值位于右侧，更新 `left = mid + 1`。
4. **循环终止条件** ：
   * 当 `left > right` 时，表示搜索范围已经缩小到无法继续（即数组中不存在目标值），此时返回 `-1`。
