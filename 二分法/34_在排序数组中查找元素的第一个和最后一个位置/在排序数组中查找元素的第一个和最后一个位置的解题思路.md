# 在排序数组中查找元素的第一个和最后一个位置

给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。

如果数组中不存在目标值 target，返回 [-1, -1]。

你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。

## 问题分析

题目要求在一个按照**非递减顺序**排列的整数数组 `nums` 中找到目标值 `target` 的**开始位置**和 **结束位置** ，并且如果目标值在数组中不存在，则返回 `[-1, -1]`。

此外，题目要求时间复杂度为 `O(log n)`。这是一个明显的提示，告诉我们应该使用**二分查找**来实现。二分查找可以在对数级别的时间内高效查找数据，是处理这类有序数组查找问题的理想算法。

## 二分算法解法

二分查找的优势在于它能够以对数级别的复杂度迅速缩小查找范围。为了找到目标值的起始位置和结束位置，我们可以分为两次独立的二分查找：

1. **第一次二分查找** 用于找到 `target` 的 **最左侧位置** 。
2. **第二次二分查找** 用于找到 `target` 的 **最右侧位置** 。

### 解题思路

1. 先进行一次二分查找，找到目标值的第一次出现位置（最左侧位置）。
2. 再进行一次二分查找，找到目标值的最后一次出现位置（最右侧位置）。
3. 如果 `target` 不存在于数组中，则返回 `[-1, -1]`。

### 二分算法的细节分析

1. **二分查找的基本逻辑** ：

* 在有序数组中进行二分查找时，我们通过计算中间位置 `mid` 来判断目标值是否在左半部分或右半部分，从而不断缩小查找范围。
* 每次查找的步骤：
  * 计算中间位置 `mid`。
  * 比较 `nums[mid]` 和目标值 `target`。
  * 如果 `nums[mid] == target`，记录该位置，然后继续向左或向右查找以找到最终的范围。
  * 如果 `nums[mid] < target`，说明目标值一定在右半部分，将 `left` 指针移动到 `mid + 1`。
  * 如果 `nums[mid] > target`，说明目标值一定在左半部分，将 `right` 指针移动到 `mid - 1`。

1. **寻找最左侧位置** ：

* 我们需要找到目标值第一次出现的位置，因此当我们找到 `target` 时，我们不能直接停止，而是应该 **继续在左侧查找** 。
* 当我们找到 `target` 时，我们将 `right` 移动到 `mid - 1`，以继续在更左侧查找目标值。
* 这样可以确保找到的最终位置是 **最左侧位置** 。

1. **寻找最右侧位置** ：

* 类似地，寻找最右侧位置时，我们希望找到目标值的最后一次出现位置。
* 当找到 `target` 时，我们将 `left` 移动到 `mid + 1`，以继续在更右侧查找目标值。
* 这样可以确保找到的最终位置是 **最右侧位置** 。
