# 寻找峰值

峰值元素是指其值严格大于左右相邻值的元素。

给你一个整数数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。

你可以假设 nums[-1] = nums[n] = -∞ 。

你必须实现时间复杂度为 O(log n) 的算法来解决此问题。


## 问题分析

在这道题目中，我们需要在一个整数数组中找到一个峰值元素的位置。峰值元素是指其值大于左右相邻值的元素，并且题目要求我们实现一个时间复杂度为 `O(log n)` 的算法来解决此问题。

题目假设数组的左右两端均为负无穷（即 `nums[-1] = nums[n] = -∞`），这使得数组的最边缘位置有可能是一个峰值。对于这种查找问题，如果要求时间复杂度为 `O(log n)`，这通常意味着要使用二分查找来进行优化。


## 二分算法解法

在 `findPeakElement` 的算法中，我们不断缩小搜索范围，直到最终 `left == right`，下面分步骤说明：

1. **初始化指针** ：

* 我们有两个指针：`left` 和 `right`，分别表示当前搜索范围的左右边界。
* 初始时，`left = 0`，`right = nums.length - 1`，整个数组都在搜索范围内。

1. **计算中间位置** ：

* 在每次循环中，我们都计算中间位置 `mid`，公式是：
* ```javascript
  mid = Math.floor((left + right) / 2);
  ```
* 通过 `mid`，我们可以将当前范围一分为二，从而减少一半的搜索空间。

1. **判断峰值的方向** ：

* 我们的目标是找到峰值，而一个峰值是指该元素大于其左右相邻元素。
* 在比较 `mid` 与 `mid + 1` 位置的值时，有两种情况：

  1. **`nums[mid] > nums[mid + 1]`** ：

     * 这种情况下，说明中间位置 `mid` 在一个下降趋势上（即 `nums[mid]` 大于其右边的元素 `nums[mid + 1]`）。
     * 因此，左侧可能存在一个峰值（因为下降趋势意味着可能会到达一个局部最大值）。
     * 我们将 `right` 移动到 `mid`。
     * 这样，`mid` 仍然在新的搜索范围内。
  2. **`nums[mid] < nums[mid + 1]`** ：

     * 这种情况下，说明中间位置 `mid` 在一个上升趋势上（即 `nums[mid]` 小于其右边的元素 `nums[mid + 1]`）。
     * 因此，右侧一定存在一个峰值，因为在上升的趋势中，最终会到达一个局部最大值。
     * 我们将 `left` 移动到 `mid + 1`。
     * 这样，`mid + 1` 变成了新的左边界，`mid` 本身被排除。
