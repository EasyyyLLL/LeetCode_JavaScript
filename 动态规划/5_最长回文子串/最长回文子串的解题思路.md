# 动态规划—最长回文子串

## 问题分析

给一个字符串 s，找到 s 中最长的回文子串。

```
s = 'ababa'
```

对于字符串 `s` ，子串 `bab` 是回文子串，两端加上相同的字符 `a` 后依然能成为回文子串。所以判断以 `s[i]` 开头和以 `s[j]` 结尾的子串是否为回文子串就需要判断该子串包裹的下一级子串（以 `s[i + 1]` 开头和以 `s[j - 1]` 结尾的子串）是否为回文子串以及 `s[i]` 与 `s[j]` 是否相等。

设 $f(i,j)$ 来表示以 `s[i]` 开头和以 `s[j]` 结尾的子串状态，当 $f(i,j) = 1$ 即这个子串是回文子串，当 $f(i,j) = 0$ 即这个子串不是回文子串。

根据上面分析，可得以下方程

$$
f(i,j) = 
\begin{cases}
1, \ f(i + 1, j - 1) = 1 and s[i] = s[j] \\
0, \ others
\end{cases}
$$

当子串逐步收缩的时候，会遇到两种情况

* 子串长度为偶数，会收缩到一个长度为2的子串；
* 子串长度为奇数，会收缩到一个长度为1的子串；

所以我们需要对长度为1和2的子串做单独判断。

* 长度为1的子串只有一个字符，所以该子串一定是回文子串；
* 长度为2的子串是回文子串当且仅当该子串的两个字符相同；


## 动态规划解法

状态为 `dp[i][j]` ，即以 `s[i]` 开头和以 `s[j]` 结尾的子串是否为回文子串，`dp[i][j] = 1` 表示子串是回文。

状态转移方程为

```js
dp[i][j] = s[i] === s[j] && dp[i + 1][j - 1] === 1 ? 1 : 0
```

还需要另外考虑长度为 1 和 2 的两个边界情况

```js
dp[i][i] = 1
dp[i][i + 1] = s[i] === s[i + 1] ? 1 : 0
```


动态规划的实现步骤：

1. 定义一个二维数组 `dp` ，用来保存子串的状态；
2. 初始化长度为 1 的子串，设状态为回文子串，即 `dp[i][i] = 1` ；
3. 判断相邻子串的状态，即当 `s[i] === s[i + 1]` 时，`dp[i][i + ] = 1` ；
4. 考虑长度大于 2 的子串，对子串的长度做遍历，判断以不同 `s[i]` 开头的不同长度的子串是否为回文子串：
   * `s[i] = s[j]` ；
   * `dp[i + 1][j - 1] = 1` ；
5. 用两个指针记录最长回文子串的起始位置和长度，最终返回该子串。
