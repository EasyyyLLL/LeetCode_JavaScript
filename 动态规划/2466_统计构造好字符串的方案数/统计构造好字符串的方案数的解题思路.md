# 统计构造好字符串的方案数

给你整数 `zero` ，`one` ，`low` 和 `high` ，我们从空字符串开始构造一个字符串，每一步执行下面操作中的一种：

- 将 `'0'` 在字符串末尾添加 `zero` 次。
- 将 `'1'` 在字符串末尾添加 `one` 次。

以上操作可以执行任意次。

如果通过以上过程得到一个 **长度** 在 `low` 和 `high` 之间（包含上下边界）的字符串，那么这个字符串我们称为 **好** 字符串。

请你返回满足以上要求的 **不同** 好字符串数目。由于答案可能很大，请将结果对 `109 + 7` **取余** 后返回。

## 问题分析

1. **初始化和操作**：
   - 我们从一个空字符串开始。
   - 每一步可以选择在字符串末尾添加`zero`个`'0'`或`one`个`'1'`。
   - 构造的字符串长度必须在 `[low, high]` 范围内（包含边界），才算是“好字符串”。
2. **多次操作构造字符串**：
   - 我们可以重复上述操作，即多次添加`zero`个`'0'`或`one`个`'1'`，最终构造出符合条件的字符串。
   - 因此，我们需要计算所有满足长度在 `[low, high]` 范围内的字符串数量。
3. **对大数取模**：
   - 答案可能非常大，所以需要对 109+710^9 + 7109+7 取模以避免溢出。

## 动态规划解法

### 动态规划解法思路

我们可以用动态规划数组 `dp[i]` 表示**构造长度为 `i` 的“好字符串”数量**。递推公式的构造基于两种操作的选择：

1. 如果我们选择添加`zero`个`'0'`，则当前字符串长度会增加 `zero`。
   - 也就是说，如果字符串在长度 `i-zero` 的状态可以构造出来，那么我们可以添加 `zero` 个 `0` 得到长度为 `i` 的字符串。
   - 因此，对于长度为 `i` 的“好字符串”数量，`dp[i]` 可以加上 `dp[i - zero]`。
2. 如果我们选择添加`one`个`'1'`，则当前字符串长度会增加 `one`。
   - 同理，从 `i-one` 的状态也可以通过添加 `one` 个 `1` 得到长度为 `i` 的字符串。
   - 因此，`dp[i]` 还可以加上 `dp[i - one]`。

### 递推公式

综上，动态规划的转移方程为：
$$
dp[i] = (dp[i - zero] + dp[i - one] ) \% MOD
$$
其中 `MOD = 10^9 + 7`，用来取模。

### 初始条件

- `dp[0] = 1`，因为空字符串也是一种有效的构造方式（相当于没有添加任何字符）。

### 目标结果

我们需要累加长度在 `[low, high]` 范围内的所有“好字符串”数量，即遍历 `dp[low]` 到 `dp[high]`，得到最终结果。

### 算法分析

1. **时间复杂度**：由于我们只需遍历到 `high`，时间复杂度为 O(high)O(\text{high})O(high)。
2. **空间复杂度**：使用了长度为 `high+1` 的数组 `dp`，空间复杂度也是 O(high)O(\text{high})O(high)。
