# 一和零

给你一个二进制字符串数组 `strs` 和两个整数 `m` 和 `n` 。

请你找出并返回 `strs` 的最大子集的长度，该子集中 **最多** 有 `m` 个 `0` 和 `n` 个 `1` 。

如果 `x` 的所有元素也是 `y` 的元素，集合 `x` 是集合 `y` 的 **子集** 。

## 问题分析

我们给出一个字符串数组 `strs`，每个字符串只包含二进制字符 '0' 和 '1'。要求找到最大子集，使得该子集的字符串总共包含的 '0' 和 '1'数量分别不超过 `m` 和 `n`。目标是最大化选择的字符串数量，即最大化子集长度。

这个问题可以抽象为多维背包问题：

- 每个字符串的 '0' 和 '1'数量可以视为其“重量”。
- 子集的长度可以视为“价值”。
- 总重量（即 0 和 1 的数量）不能超过给定的 `m` 和 `n`。


## 动态规划解法

### **定义状态**

定义 `dp[k][i][j]` 表示在最多使用 `k` 个字符串且包含最多 `i` 个 0 和 `j` 个 1 的情况下，最大子集的长度。

### **状态转移方程**

对于每个字符串 `strs[k]`，统计其中的 '0' 和 '1' 的数量，记为 `zeroCount` 和 `oneCount`。

1. 如果不选择当前字符串 `strs[k]`，则当前状态 `dp[k][i][j]` 可以从 `dp[k-1][i][j]` 转移而来。
2. 如果选择当前字符串 `strs[k]`，那么状态可以从 `dp[k-1][i-zeroCount][j-oneCount]` 转移而来，并且选择该字符串会让子集的大小增加 1。

因此，状态转移方程为：
$$
dp[k][i][j]=max⁡(dp[k−1][i][j],dp[k−1][i−zeroCount][j−oneCount]+1)dp[k][i][j] = \max(dp[k-1][i][j], dp[k-1][i-zeroCount][j-oneCount] + 1)dp[k][i][j]=max(dp[k−1][i][j],dp[k−1][i−zeroCount][j−oneCount]+1)
$$


### **边界情况**

初始状态下，`dp[0][i][j] = 0`，表示没有选择任何字符串时，最大子集长度为 0。

### **结果**

遍历所有状态，最终的 `dp[strs.length][m][n]` 即为满足条件的最大子集长度。
