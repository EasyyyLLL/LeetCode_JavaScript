# 最小高度树

## 问题分析

我们需要找到树中所有的**最小高度树**的根节点标签。问题描述为：

* 树包含 `n` 个节点，节点从 `0` 到 `n-1`，有 `n-1` 条无向边。
* 树的**高度**定义为从根节点到最远叶子节点的路径边的数量。
* 目标是找出所有可能的根节点，使得树的高度最小。

这个问题的本质是找到一棵树的 **最小高度树（Minimum Height Tree, MHT）** ，通常适合通过剪枝和迭代的方式来解决，特别是找到所有的 **最小高度根节点** 。最小高度树的根节点一般处于图的中心位置，或者说 **中心节点** 。

### 问题特点

* **树的高度** ：在无向图中选择任意节点作为根节点时，树的高度取决于从根到最远叶子节点的路径。
* **中心节点** ：最小高度树的根节点必定是树的中心节点，或者中心节点相邻的节点。
* **叶节点** ：由于叶节点是最外层节点，移除叶节点后，剩下的树可以更容易找到中心。

## 深度优先搜索解法

### 解题思路

我们可以将这个问题看作找到树的 **拓扑中心** ：

1. **找中心节点** ：对于树来说，中心节点通常会是树的“最中间”位置，避免向各个方向延伸太多。
2. **层次遍历移除叶节点** ：
   * 我们可以把这棵树看成一个无向图。
   * 从所有的叶节点开始逐层移除，直到剩下 1 个或 2 个节点为止，这些节点就是最小高度树的根节点。

### 具体步骤

1. **创建图的表示形式** ：用邻接列表来表示无向图。
2. **初始化叶节点** ：找到所有只有一个邻居的节点作为叶节点。
3. **逐步移除叶节点** ：
   * 每次移除当前所有的叶节点，并更新相应的邻接关系。
   * 当剩余节点少于等于 2 个时，停止移除。
   * 剩余的节点就是最小高度树的根节点。


### 核心思想：寻找树的中心节点

* 在一棵树中，**最小高度树的根节点**就是这棵树的 **中心节点** 。从树的结构来看，树的中心是最平衡的位置，能够确保所有路径到达叶节点的长度最小化。
* 如果我们能找到树的中心节点，那么以该节点为根节点的树的高度就是最小的。因此，找到树的中心节点，是解决这个问题的关键。


### 为什么要逐步移除叶节点

逐步移除叶节点的过程，实际上是一种**缩小搜索范围**的策略，旨在找到树的中心。具体来说：

1. **叶节点的特性** ：

   * **叶节点**是那些只有**一个邻居**的节点，位于树的最外层。
   * **中心节点**则是与叶节点最远、相对树的“最中间”的位置。
   * 因此，我们可以通过 **逐层移除最外层的叶节点** ，使得剩余部分的树逐步向中心缩小。
2. **层次收缩树** ：

   * 每次移除当前所有的叶节点，剩下的部分就变成了一棵更小的树。
   * 通过反复移除叶节点，逐步缩小树的大小，树的层数不断减少。
   * 当剩余的节点数小于等于 `2` 个时，这些节点就是 **树的中心节点** ，也是最小高度树的根节点。
3. **找到最小高度树的根节点** ：

   * 树的中心可能是**一个节点**或者 **两个节点** ，这取决于树的节点数是奇数还是偶数。
   * 当剩余节点数为 `1` 时，该节点就是树的中心。
   * 当剩余节点数为 `2` 时，这两个节点之间的边就是树的“中心”，它们是高度相同的、平衡的位置。

**例子**

考虑一个简单的树结构：

```markdown
      1
     / \
    0   2
         \
          3

```

1. 初始叶节点为 `[0, 3]`。
2. 移除叶节点 `0` 和 `3`，树变成：

   ```markdown
      1
       \
        2

   ```

   新的叶节点为 `[1, 2]`。
3. 移除叶节点 `1` 和 `2`，只剩下节点 `1` 和 `2`。


### 算法思想解析

1. **特殊情况处理** ：

   * 如果 `n === 1`，直接返回 `[0]`，因为只有一个节点的树的根就是它本身。
2. **构建邻接列表** ：

   * 使用邻接列表 `adjList` 表示无向图。
   * 对于每条边 `edges[i] = [a, b]`，将 `a` 和 `b` 互相加入到对方的邻接列表中，表示 `a` 和 `b` 之间存在连接。
3. **初始化叶节点** ：

   * **叶节点**的定义是 **只有一个邻居的节点** 。
   * 遍历所有节点，找出邻接节点数量为 1 的节点，将它们作为初始的叶节点加入到数组 `leaves` 中。
4. **逐层移除叶节点** ：

   * 使用 `while (remainingNodes > 2)` 循环，逐步移除叶节点。
   * 每一轮中，将当前的叶节点从图中移除，同时更新其邻居节点：
     * 对于每个叶节点，从其邻接列表中找到它的邻居，然后将自己从邻居的邻接列表中移除。
     * 如果邻居节点变成了新的叶节点（即只剩下一个邻居），则将其加入到新的叶节点列表中。
   * 重复这一过程，直到剩下的节点数不超过 2。
5. **剩余节点即为最小高度树的根节点** ：

   * 当剩余节点数小于等于 2 时，这些节点就是树的中心节点，返回它们即可。

### 时间复杂度和空间复杂度

* **时间复杂度** ：`O(n)`，因为每个节点和边都只会被访问和处理一次。
* **空间复杂度** ：`O(n)`，用于存储邻接列表和叶节点列表。
