# 翻转等价二叉树

我们可以为二叉树 T 定义一个 翻转操作 ，如下所示：选择任意节点，然后交换它的左子树和右子树。

只要经过一定次数的翻转操作后，能使 X 等于 Y，我们就称二叉树 X 翻转 等价 于二叉树 Y。

这些树由根节点 root1 和 root2 给出。如果两个二叉树是否是翻转 等价 的函数，则返回 true ，否则返回 false 。

## 问题分析

在这道题目中，我们要判断两棵二叉树是否 **翻转等价** 。所谓的 **翻转等价** ，是指可以通过**若干次翻转**使得两棵树完全相同。翻转操作定义为对树中的任意节点，其 **左子树和右子树交换** ，并且可以对任意多个节点进行翻转。

例如：

* **初始状态** ：给定两棵树 `root1` 和 `root2`。
* **目标** ：通过若干次翻转操作后，使得 `root1` 和 `root2` 的形状和结构完全一致。

### 翻转等价

对于给定的两棵二叉树 `X` 和 `Y`，它们被称为**翻转等价**的，意味着以下条件之一必须满足：

1. **根节点值相同** 。
2. 两棵树的子树能够通过以下两种方式之一匹配：
   * **不翻转的情况** ：`X.left` 与 `Y.left` 相同，且 `X.right` 与 `Y.right` 相同。
   * **翻转的情况** ：`X.left` 与 `Y.right` 相同，且 `X.right` 与 `Y.left` 相同。

**翻转等价**的核心思想在于：

* 在任意节点，我们可以选择是否交换它的左右子树。
* 如果通过一系列这样的翻转操作，能够使两棵树完全相等，那么它们就是翻转等价的。

### 解题思路

为了判断两棵二叉树是否翻转等价，我们可以使用**递归的深度优先搜索（DFS）**来逐步判断两个树的节点是否符合翻转等价的条件。


## 深度优先搜索解法

### 递归思想

递归是解决这个问题的关键。对每一个节点，我们都要考虑它有两种可能的等价情况：

1. **不翻转的情况下** ，左子树对应左子树，右子树对应右子树。
2. **翻转的情况下** ，左子树对应右子树，右子树对应左子树。

递归地去判断这两种情况，只要有一种情况成立，就可以认为这两个节点的子树是等价的，进而整棵树也是等价的。

### 递归条件

为了实现递归判断，需要明确以下几种情况：

1. **递归终止条件** ：

   * **两个节点都为空** ：如果 `root1` 和 `root2` 都是 `null`，说明两个子树都是空的，因此它们是等价的，返回 `true`。
   * **只有一个节点为空** ：如果 `root1` 或 `root2` 其中一个是 `null`，而另一个不是，显然它们不等价，返回 `false`。
   * **根节点值不同** ：如果 `root1.val` 和 `root2.val` 不相等，说明两个节点的值不同，因此它们不等价，返回 `false`。
2. **递归继续条件** ：

   * **不翻转的情况** ：比较两棵树的左子树和右子树，即判断 `root1.left` 和 `root2.left` 是否翻转等价，以及 `root1.right` 和 `root2.right` 是否翻转等价。
   * **翻转的情况** ：考虑将一棵树的左右子树翻转，即判断 `root1.left` 和 `root2.right` 是否翻转等价，以及 `root1.right` 和 `root2.left` 是否翻转等价。

只要有一种情况成立（即不翻转或翻转），就可以说明两个子树在当前节点下是翻转等价的。

### 深度优先搜索（DFS）解决思路

1. **递归地遍历两个树的每一个节点** 。
2. 对每一个节点，检查以下条件：
   * 如果两个节点都是空，则它们是等价的。
   * 如果其中一个为空或者两个节点的值不相等，则它们不等价。
   * 然后递归地检查：
     * **不翻转的情况** ：左对左，右对右。
     * **翻转的情况** ：左对右，右对左。
   * 如果任意一种情况成立，则返回 `true`，否则返回 `false`。
3. 递归过程自顶向下，直到叶节点或发现不等价的节点为止。
