# 输出二叉树


给你一棵二叉树的根节点 root ，请你构造一个下标从 0 开始、大小为 m x n 的字符串矩阵 res ，用以表示树的 格式化布局 。构造此格式化布局矩阵需要遵循以下规则：

树的 高度 为 height ，矩阵的行数 m 应该等于 height + 1 。
矩阵的列数 n 应该等于 $2^{height+1} - 1$ 。
根节点 需要放置在 顶行 的 正中间 ，对应位置为 res[0][(n-1)/2] 。
对于放置在矩阵中的每个节点，设对应位置为 res[r][c] ，将其左子节点放置在 res[r+1][c-$2^{height-r-1}$] ，右子节点放置在 res[r+1][c+$2^{height-r-1}$] 。
继续这一过程，直到树中的所有节点都妥善放置。
任意空单元格都应该包含空字符串 "" 。
返回构造得到的矩阵 res

## 问题分析

这道题目要求你将一棵二叉树格式化地表示为一个 **字符串矩阵** 。具体来说，树的每个节点需要放置在矩阵的合适位置，形成层次化的格式展示。这个问题的核心是确定每个节点的位置和如何填充矩阵。我们可以利用树的递归遍历（例如深度优先搜索，DFS）来解决。

### 问题细化

给定一棵二叉树的根节点 `root`，我们需要构造一个下标从 `0` 开始的字符串矩阵 `res`，遵循以下要求：

1. **矩阵的行数 `m`** 等于树的高度 `height + 1`。
2. **矩阵的列数 `n`** 等于 `2^(height+1) - 1`。
3. **根节点** 需要放置在 **第一行的正中间** 。
4. 对于每一个节点，将其左子节点和右子节点依次放在矩阵的适当位置，形成格式化的布局。
5. **空单元格**用空字符串 `""` 表示。

### 解题思路

1. **计算树的高度** ：

* 树的高度 `height` 是从根节点到最深的叶节点的最长路径上的边数。
* 我们可以使用递归来计算树的高度。

1. **初始化矩阵** ：

* 矩阵的**行数**为 `height + 1`。
* 矩阵的**列数**为 `2^(height + 1) - 1`。
* 初始化一个大小为 `m x n` 的二维数组，所有位置填充空字符串 `""`。

1. **递归填充矩阵** ：

* 使用深度优先搜索（DFS）递归地遍历每个节点。
* 对于每个节点，将它放在适当的行和列。
* 根据题目要求，根节点的位置是正中间，左子节点和右子节点依次根据公式计算它们的位置。

## 深度优先搜索解法

### 算法思想解析

1. **树的高度计算** ：

   * 使用递归计算树的高度，以便确定矩阵的行数和列数。
   * **高度**的定义是：从根节点到最深叶节点的路径上的最大边数。
   * 如果当前节点为 `null`，其高度为 `-1`，否则高度为 `1 + max(左子树高度, 右子树高度)`。
2. **初始化矩阵** ：

   * 矩阵行数等于树的高度加 1。
   * 矩阵列数为 `2^(height + 1) - 1`，确保树在矩阵中可以格式化显示。
   * 初始化矩阵，所有位置用空字符串 `""` 填充。
3. **递归填充矩阵** ：

   * 使用深度优先搜索（DFS）递归地填充矩阵。
   * **根节点的位置**在矩阵的**第一行**的正中间（即 `(n-1)/2`）。
   * **递归逻辑** ：
     * 设 `r` 为当前行，`c` 为当前列，`levelWidth` 为当前的宽度层级。
     * 对于左子节点：
       * 它位于下一行 `r + 1`，并且其列的位置为 `c - 2^(height-r-1)`。
     * 对于右子节点：
       * 它位于下一行 `r + 1`，并且其列的位置为 `c + 2^(height-r-1)`。
       * 递归地对每个子节点调用 `fill`，直到所有节点都被填充。
4. **矩阵填充位置的计算** ：

   * **位置的选择** ：
     * 根节点总是放在**正中间**的位置。
     * 对于每一个节点，它的左右子节点的水平位置可以通过减去或增加 `2^(height-r-1)` 来确定。
     * 这样确保了子节点放置得足够分散，使得整个树的结构看起来是对称的。
