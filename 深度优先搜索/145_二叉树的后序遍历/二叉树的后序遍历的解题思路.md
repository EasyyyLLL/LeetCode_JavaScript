# 二叉树的后序遍历

给你一棵二叉树的根节点 root ，返回其节点值的 后序遍历 。

## 问题分析

 **后序遍历** （Postorder Traversal）是一种二叉树遍历方式，访问树的节点顺序为：

1. 遍历 **左子树** 。
2. 遍历 **右子树** 。
3. 访问 **根节点** 。

因此，在后序遍历中，根节点的值会在**最后**被访问。

## 深度优先搜索解法

后序遍历的特点是：在遍历一个节点时，必须确保它的**左子树和右子树**都已经被完全遍历。我们可以使用递归来实现这种遍历，因为递归非常自然地适合表达这种自下而上的遍历模式。

在实现后序遍历时，我们的目标是：

* **首先遍历左子树** 。
* **然后遍历右子树** 。
* **最后访问根节点** 。

### 递归深度优先搜索的步骤

1. 从根节点开始，首先递归遍历 **左子树** 。
2. 递归遍历 **右子树** 。
3. 访问当前的 **根节点** ，并将它的值加入结果数组中。

### 解题思路分析

1. **结果数组的初始化** ：

* 创建一个结果数组 `result`，用于存储后序遍历的节点值，最终返回这个数组。

1. **递归函数 `dfs`** ：

* `dfs` 是用于遍历树的递归函数，接受一个节点 `node` 作为参数。
* 如果当前节点 `node` 是 `null`，直接返回，表示已经到达了叶节点的子节点。
* 首先递归调用 `dfs(node.left)`，以遍历 **左子树** 。
* 接着递归调用 `dfs(node.right)`，以遍历 **右子树** 。
* 最后将当前节点的值 `node.val` 添加到结果数组 `result` 中，表示在左右子树遍历完成之后访问当前节点。

1. **调用递归函数** ：

* 最终，从根节点 `root` 开始调用 `dfs(root)`，以递归地进行整个二叉树的后序遍历。

### 时间复杂度和空间复杂度

* **时间复杂度** ：`O(n)`，其中 `n` 是二叉树的节点数量。每个节点只被访问一次，因此时间复杂度为线性。
* **空间复杂度** ：`O(n)`，空间复杂度与树的高度有关，最坏情况下是 `O(n)`（例如链状结构的树），平均情况下是 `O(log n)`（例如平衡二叉树）。
