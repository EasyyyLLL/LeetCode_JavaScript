# 二叉树展开为链表

给你二叉树的根结点 root ，请你将它展开为一个单链表：

展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。
展开后的单链表应该与二叉树 先序遍历 顺序相同。


## 问题分析

这道题要求我们将给定的二叉树**原地展开**为一个 **单链表** ，其中：

* **右子指针**指向链表中的下一个节点。
* **左子指针始终为 `null`** 。

展开后的单链表应该**按照二叉树的前序遍历顺序**构建，即我们要按前序遍历的顺序访问每一个节点，然后调整各节点的指针，使它们的右子指针连接到下一个节点，而左子指针为 `null`。


## 深度优先搜索解法

### 深度优先搜索的解法步骤

1. 从根节点开始进行前序遍历。
2. 使用递归或迭代的方式找到前序遍历的顺序，然后将每个节点的 **右子指针指向下一个节点** 。
3. 将每个节点的 **左子指针设为 `null`** 。

### 算法思想解析

1. **结果变量的初始化** ：

* 使用变量 `prev` 来记录 **前一个访问到的节点** 。这样，在每次递归访问节点时，我们可以将当前节点的右子指针指向 `prev`。

1. **递归函数 `dfs`** ：

* `dfs` 是一个递归函数，接受一个节点 `node` 作为参数。
* 遍历顺序为 **右子树、左子树、当前节点** ：
  * **递归遍历右子树** ：因为展开后的单链表应该按照前序遍历的顺序展开，因此我们需要先处理右子树，使得在展开左子树后，原来的右子树能够连接到展开结果的最后。
  * **递归遍历左子树** ：接着，我们处理左子树。
  * **处理当前节点** ：
  * 将当前节点的右指针 `node.right` 设置为 `prev`（上一次处理的节点）。
  * 将当前节点的左指针 `node.left` 设为 `null`。
  * 更新 `prev` 为当前节点。

1. **从根节点开始递归调用** ：

* 从根节点开始调用 `dfs(root)`，递归地将整棵树按照前序遍历顺序展开成单链表。

### 为什么选择这样的递归顺序

* 我们采用**先右后左**的递归顺序是为了保证处理左子树之前，右子树已经完全展开并连接好。这种顺序保证了当我们处理左子树时，右子树已经被处理完毕，因此左子树可以直接连接到右子树前面。
* 通过使用一个 `prev` 变量，我们能够跟踪前一个节点，以便设置当前节点的右指针指向它。
